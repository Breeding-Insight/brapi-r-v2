# BrAPI-Core
#
# The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
#
# The version of the OpenAPI document: 2.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title VariantSets operations
#' @description openapi.VariantSets
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ SearchVariantsetsPost } \emph{ Gets a list of &#x60;VariantSet&#x60; matching the search criteria. }
#' Gets a list of &#x60;VariantSet&#x60; matching the search criteria.
#'
#' \itemize{
#' \item \emph{ @param } authorization character
#' \item \emph{ @param } variant.sets.search.request \link{VariantSetsSearchRequest}
#' \item \emph{ @returnType } \link{VariantSetsListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : VariantSetsListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 202 | Accepted
#'
#' \item return type : Accepted202SearchResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SearchVariantsetsSearchResultsDbIdGet } \emph{ Gets a list of &#x60;VariantSet&#x60; matching the search criteria. }
#' Gets a list of &#x60;VariantSet&#x60; matching the search criteria.
#'
#' \itemize{
#' \item \emph{ @param } search.results.db.id character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{VariantSetsListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : VariantSetsListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 202 | Accepted
#'
#' \item return type : Accepted202SearchResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VariantsetsExtractPost } \emph{ Create new &#x60;VariantSet&#x60; based on search results }
#' Will perform a search for &#x60;Calls&#x60; which match the search criteria in &#x60;variantSetsExtractRequest&#x60;. The results of the search will be used to create a new &#x60;VariantSet&#x60; on the server. The new &#x60;VariantSet&#x60; will be returned.
#'
#' \itemize{
#' \item \emph{ @param } authorization character
#' \item \emph{ @param } variant.sets.extract.request \link{VariantSetsExtractRequest}
#' \item \emph{ @returnType } \link{VariantSetResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : VariantSetResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not Found
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VariantsetsGet } \emph{ Gets a filtered list of &#x60;VariantSets&#x60;. }
#' Will return a filtered list of &#x60;VariantSet&#x60;.
#'
#' \itemize{
#' \item \emph{ @param } variant.set.db.id character
#' \item \emph{ @param } variant.db.id character
#' \item \emph{ @param } call.set.db.id character
#' \item \emph{ @param } study.db.id character
#' \item \emph{ @param } study.name character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{VariantSetsListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : VariantSetsListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VariantsetsVariantSetDbIdCallsGet } \emph{ Gets a list of &#x60;Calls&#x60; associated with a &#x60;VariantSet&#x60;. }
#' Gets a list of &#x60;Calls&#x60; associated with a &#x60;VariantSet&#x60;.  ** THIS ENDPOINT USES TOKEN BASED PAGING **
#'
#' \itemize{
#' \item \emph{ @param } variant.set.db.id character
#' \item \emph{ @param } expand.homozygotes character
#' \item \emph{ @param } unknown.string character
#' \item \emph{ @param } sep.phased character
#' \item \emph{ @param } sep.unphased character
#' \item \emph{ @param } page.token character
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{CallsListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : CallsListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VariantsetsVariantSetDbIdCallsetsGet } \emph{ Gets a list of &#x60;CallSets&#x60; associated with a &#x60;VariantSet&#x60;. }
#' Gets a list of &#x60;CallSets&#x60; associated with a &#x60;VariantSet&#x60;.
#'
#' \itemize{
#' \item \emph{ @param } variant.set.db.id character
#' \item \emph{ @param } call.set.db.id character
#' \item \emph{ @param } call.set.name character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{CallSetsListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : CallSetsListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VariantsetsVariantSetDbIdGet } \emph{ Gets a &#x60;VariantSet&#x60; by ID. }
#' This call will return a JSON version of a &#x60;VariantSet&#x60;.
#'
#' \itemize{
#' \item \emph{ @param } variant.set.db.id character
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{VariantSetResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : VariantSetResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not Found
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VariantsetsVariantSetDbIdVariantsGet } \emph{ Gets a &#x60;Variants&#x60; for a given &#x60;VariantSet&#x60;. }
#' This call will return an array of &#x60;Variants&#x60;.  ** THIS ENDPOINT USES TOKEN BASED PAGING **
#'
#' \itemize{
#' \item \emph{ @param } variant.set.db.id character
#' \item \emph{ @param } variant.db.id character
#' \item \emph{ @param } page.token character
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{VariantsListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : VariantsListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  SearchVariantsetsPost  ####################
#'
#' library(openapi)
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#' var.variant.sets.search.request <- VariantSetsSearchRequest$new() # VariantSetsSearchRequest | Study Search request
#'
#' #Gets a list of `VariantSet` matching the search criteria.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$SearchVariantsetsPost(authorization=var.authorization, variant.sets.search.request=var.variant.sets.search.request)
#'
#'
#' ####################  SearchVariantsetsSearchResultsDbIdGet  ####################
#'
#' library(openapi)
#' var.search.results.db.id <- 'search.results.db.id_example' # character | Unique identifier which references the search results
#' var.page <- 0 # integer | Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is 'page'= 0). Default is `0`.
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a list of `VariantSet` matching the search criteria.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$SearchVariantsetsSearchResultsDbIdGet(var.search.results.db.id, page=var.page, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' ####################  VariantsetsExtractPost  ####################
#'
#' library(openapi)
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#' var.variant.sets.extract.request <- VariantSetsExtractRequest$new() # VariantSetsExtractRequest | Study Search request
#'
#' #Create new `VariantSet` based on search results
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VariantsetsExtractPost(authorization=var.authorization, variant.sets.extract.request=var.variant.sets.extract.request)
#'
#'
#' ####################  VariantsetsGet  ####################
#'
#' library(openapi)
#' var.variant.set.db.id <- 'variant.set.db.id_example' # character | The ID of the `VariantSet` to be retrieved.
#' var.variant.db.id <- 'variant.db.id_example' # character | The ID of the `Variant` to be retrieved.
#' var.call.set.db.id <- 'call.set.db.id_example' # character | The ID of the `CallSet` to be retrieved.
#' var.study.db.id <- 'study.db.id_example' # character | Filter by study DbId
#' var.study.name <- 'study.name_example' # character | Filter by study name
#' var.page <- 0 # integer | Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is 'page'= 0). Default is `0`.
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a filtered list of `VariantSets`.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VariantsetsGet(variant.set.db.id=var.variant.set.db.id, variant.db.id=var.variant.db.id, call.set.db.id=var.call.set.db.id, study.db.id=var.study.db.id, study.name=var.study.name, page=var.page, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' ####################  VariantsetsVariantSetDbIdCallsGet  ####################
#'
#' library(openapi)
#' var.variant.set.db.id <- 'variant.set.db.id_example' # character | The ID of the `VariantSet` to be retrieved.
#' var.expand.homozygotes <- 'expand.homozygotes_example' # character | Should homozygotes be expanded (true) or collapsed into a single occurrence (false)
#' var.unknown.string <- 'unknown.string_example' # character | The string to use as a representation for missing data
#' var.sep.phased <- 'sep.phased_example' # character | The string to use as a separator for phased allele calls
#' var.sep.unphased <- 'sep.unphased_example' # character | The string to use as a separator for unphased allele calls
#' var.page.token <- '33c27874' # character | Used to request a specific page of data to be returned.  Tokenized pages are for large data sets which can not be efficiently broken into indexed pages. Use the nextPageToken and prevPageToken from a prior response to construct a query and move to the next or previous page respectively. 
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a list of `Calls` associated with a `VariantSet`.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VariantsetsVariantSetDbIdCallsGet(var.variant.set.db.id, expand.homozygotes=var.expand.homozygotes, unknown.string=var.unknown.string, sep.phased=var.sep.phased, sep.unphased=var.sep.unphased, page.token=var.page.token, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' ####################  VariantsetsVariantSetDbIdCallsetsGet  ####################
#'
#' library(openapi)
#' var.variant.set.db.id <- 'variant.set.db.id_example' # character | The ID of the `VariantSet` to be retrieved.
#' var.call.set.db.id <- 'call.set.db.id_example' # character | The ID of the `CallSet` to be retrieved.
#' var.call.set.name <- 'call.set.name_example' # character | The human readable name of the `CallSet` to be retrieved.
#' var.page <- 0 # integer | Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is 'page'= 0). Default is `0`.
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a list of `CallSets` associated with a `VariantSet`.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VariantsetsVariantSetDbIdCallsetsGet(var.variant.set.db.id, call.set.db.id=var.call.set.db.id, call.set.name=var.call.set.name, page=var.page, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' ####################  VariantsetsVariantSetDbIdGet  ####################
#'
#' library(openapi)
#' var.variant.set.db.id <- 'variant.set.db.id_example' # character | The ID of the `Variant` to be retrieved.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a `VariantSet` by ID.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VariantsetsVariantSetDbIdGet(var.variant.set.db.id, authorization=var.authorization)
#'
#'
#' ####################  VariantsetsVariantSetDbIdVariantsGet  ####################
#'
#' library(openapi)
#' var.variant.set.db.id <- 'variant.set.db.id_example' # character | The ID of the `VariantSet` to be retrieved.
#' var.variant.db.id <- 'variant.db.id_example' # character | The ID of the `Variant` to be retrieved.
#' var.page.token <- '33c27874' # character | Used to request a specific page of data to be returned.  Tokenized pages are for large data sets which can not be efficiently broken into indexed pages. Use the nextPageToken and prevPageToken from a prior response to construct a query and move to the next or previous page respectively. 
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a `Variants` for a given `VariantSet`.
#' api.instance <- VariantSetsApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VariantsetsVariantSetDbIdVariantsGet(var.variant.set.db.id, variant.db.id=var.variant.db.id, page.token=var.page.token, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
VariantSetsApi <- R6::R6Class(
  'VariantSetsApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    SearchVariantsetsPost = function(authorization=NULL, variant.sets.search.request=NULL, ...){
      apiResponse <- self$SearchVariantsetsPostWithHttpInfo(authorization, variant.sets.search.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SearchVariantsetsPostWithHttpInfo = function(authorization=NULL, variant.sets.search.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      headerParams['Authorization'] <- `authorization`

      if (!missing(`variant.sets.search.request`)) {
        body <- `variant.sets.search.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/search/variantsets"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "VariantSetsListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SearchVariantsetsSearchResultsDbIdGet = function(search.results.db.id, page=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$SearchVariantsetsSearchResultsDbIdGetWithHttpInfo(search.results.db.id, page, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SearchVariantsetsSearchResultsDbIdGetWithHttpInfo = function(search.results.db.id, page=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`search.results.db.id`)) {
        stop("Missing required parameter `search.results.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/search/variantsets/{searchResultsDbId}"
      if (!missing(`search.results.db.id`)) {
        urlPath <- gsub(paste0("\\{", "searchResultsDbId", "\\}"), URLencode(as.character(`search.results.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "VariantSetsListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VariantsetsExtractPost = function(authorization=NULL, variant.sets.extract.request=NULL, ...){
      apiResponse <- self$VariantsetsExtractPostWithHttpInfo(authorization, variant.sets.extract.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VariantsetsExtractPostWithHttpInfo = function(authorization=NULL, variant.sets.extract.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      headerParams['Authorization'] <- `authorization`

      if (!missing(`variant.sets.extract.request`)) {
        body <- `variant.sets.extract.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/variantsets/extract"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "VariantSetResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VariantsetsGet = function(variant.set.db.id=NULL, variant.db.id=NULL, call.set.db.id=NULL, study.db.id=NULL, study.name=NULL, page=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$VariantsetsGetWithHttpInfo(variant.set.db.id, variant.db.id, call.set.db.id, study.db.id, study.name, page, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VariantsetsGetWithHttpInfo = function(variant.set.db.id=NULL, variant.db.id=NULL, call.set.db.id=NULL, study.db.id=NULL, study.name=NULL, page=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      headerParams['Authorization'] <- `authorization`

      queryParams['variantSetDbId'] <- variant.set.db.id

      queryParams['variantDbId'] <- variant.db.id

      queryParams['callSetDbId'] <- call.set.db.id

      queryParams['studyDbId'] <- study.db.id

      queryParams['studyName'] <- study.name

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/variantsets"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "VariantSetsListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VariantsetsVariantSetDbIdCallsGet = function(variant.set.db.id, expand.homozygotes=NULL, unknown.string=NULL, sep.phased=NULL, sep.unphased=NULL, page.token=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$VariantsetsVariantSetDbIdCallsGetWithHttpInfo(variant.set.db.id, expand.homozygotes, unknown.string, sep.phased, sep.unphased, page.token, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VariantsetsVariantSetDbIdCallsGetWithHttpInfo = function(variant.set.db.id, expand.homozygotes=NULL, unknown.string=NULL, sep.phased=NULL, sep.unphased=NULL, page.token=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`variant.set.db.id`)) {
        stop("Missing required parameter `variant.set.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      queryParams['expandHomozygotes'] <- expand.homozygotes

      queryParams['unknownString'] <- unknown.string

      queryParams['sepPhased'] <- sep.phased

      queryParams['sepUnphased'] <- sep.unphased

      queryParams['pageToken'] <- page.token

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/variantsets/{variantSetDbId}/calls"
      if (!missing(`variant.set.db.id`)) {
        urlPath <- gsub(paste0("\\{", "variantSetDbId", "\\}"), URLencode(as.character(`variant.set.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CallsListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VariantsetsVariantSetDbIdCallsetsGet = function(variant.set.db.id, call.set.db.id=NULL, call.set.name=NULL, page=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$VariantsetsVariantSetDbIdCallsetsGetWithHttpInfo(variant.set.db.id, call.set.db.id, call.set.name, page, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VariantsetsVariantSetDbIdCallsetsGetWithHttpInfo = function(variant.set.db.id, call.set.db.id=NULL, call.set.name=NULL, page=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`variant.set.db.id`)) {
        stop("Missing required parameter `variant.set.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      queryParams['callSetDbId'] <- call.set.db.id

      queryParams['callSetName'] <- call.set.name

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/variantsets/{variantSetDbId}/callsets"
      if (!missing(`variant.set.db.id`)) {
        urlPath <- gsub(paste0("\\{", "variantSetDbId", "\\}"), URLencode(as.character(`variant.set.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CallSetsListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VariantsetsVariantSetDbIdGet = function(variant.set.db.id, authorization=NULL, ...){
      apiResponse <- self$VariantsetsVariantSetDbIdGetWithHttpInfo(variant.set.db.id, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VariantsetsVariantSetDbIdGetWithHttpInfo = function(variant.set.db.id, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`variant.set.db.id`)) {
        stop("Missing required parameter `variant.set.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      body <- NULL
      urlPath <- "/variantsets/{variantSetDbId}"
      if (!missing(`variant.set.db.id`)) {
        urlPath <- gsub(paste0("\\{", "variantSetDbId", "\\}"), URLencode(as.character(`variant.set.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "VariantSetResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VariantsetsVariantSetDbIdVariantsGet = function(variant.set.db.id, variant.db.id=NULL, page.token=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$VariantsetsVariantSetDbIdVariantsGetWithHttpInfo(variant.set.db.id, variant.db.id, page.token, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VariantsetsVariantSetDbIdVariantsGetWithHttpInfo = function(variant.set.db.id, variant.db.id=NULL, page.token=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`variant.set.db.id`)) {
        stop("Missing required parameter `variant.set.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      queryParams['variantDbId'] <- variant.db.id

      queryParams['pageToken'] <- page.token

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/variantsets/{variantSetDbId}/variants"
      if (!missing(`variant.set.db.id`)) {
        urlPath <- gsub(paste0("\\{", "variantSetDbId", "\\}"), URLencode(as.character(`variant.set.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "VariantsListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
