# BrAPI-Core
#
# The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
#
# The version of the OpenAPI document: 2.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title References operations
#' @description openapi.References
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ReferencesGet } \emph{ Gets a filtered list of &#x60;Reference&#x60; objects. }
#' &#x60;GET /references&#x60; will return a filtered list of &#x60;Reference&#x60; JSON objects.
#'
#' \itemize{
#' \item \emph{ @param } reference.db.id character
#' \item \emph{ @param } reference.set.db.id character
#' \item \emph{ @param } accession character
#' \item \emph{ @param } md5checksum character
#' \item \emph{ @param } is.derived character
#' \item \emph{ @param } min.length integer
#' \item \emph{ @param } max.length integer
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{ReferencesListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : ReferencesListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ReferencesReferenceDbIdBasesGet } \emph{ Lists &#x60;Reference&#x60; bases by ID and optional range. }
#' Lists &#x60;Reference&#x60; bases by ID and optional range.
#'
#' \itemize{
#' \item \emph{ @param } reference.db.id character
#' \item \emph{ @param } start integer
#' \item \emph{ @param } end integer
#' \item \emph{ @param } page.token character
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{ReferenceBasesResponse} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : ReferenceBasesResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not Found
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ReferencesReferenceDbIdGet } \emph{ Gets a &#x60;Reference&#x60; by ID. }
#' &#x60;GET /references/{reference_id}&#x60; will return a JSON version of &#x60;Reference&#x60;.
#'
#' \itemize{
#' \item \emph{ @param } reference.db.id character
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{ReferenceSingleResponse} \cr
#'
#'
#' \item status code : 200 | A successful response.
#'
#' \item return type : ReferenceSingleResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not Found
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SearchReferencesPost } \emph{ Gets a list of &#x60;Reference&#x60; matching the search criteria. }
#' &#x60;POST /references/search&#x60; must accept a JSON version of &#x60;SearchReferencesRequest&#x60; as the post body and will return a JSON version of &#x60;SearchReferencesResponse&#x60;.
#'
#' \itemize{
#' \item \emph{ @param } authorization character
#' \item \emph{ @param } references.search.request \link{ReferencesSearchRequest}
#' \item \emph{ @returnType } \link{ReferencesListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : ReferencesListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 202 | Accepted
#'
#' \item return type : 202AcceptedSearchResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SearchReferencesSearchResultsDbIdGet } \emph{ Gets a list of &#x60;Reference&#x60; matching the search criteria. }
#' &#x60;POST /references/search&#x60; must accept a JSON version of &#x60;SearchReferencesRequest&#x60; as the post body and will return a JSON version of &#x60;SearchReferencesResponse&#x60;.
#'
#' \itemize{
#' \item \emph{ @param } search.results.db.id character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size integer
#' \item \emph{ @param } authorization character
#' \item \emph{ @returnType } \link{ReferencesListResponse} \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : ReferencesListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 202 | Accepted
#'
#' \item return type : 202AcceptedSearchResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ReferencesGet  ####################
#'
#' library(openapi)
#' var.reference.db.id <- 'reference.db.id_example' # character | The ID of the `Reference` to be retrieved.
#' var.reference.set.db.id <- 'reference.set.db.id_example' # character | The ID of the `ReferenceSet` to be retrieved.
#' var.accession <- 'accession_example' # character | If set, return the reference sets for which the `accession` matches this string (case-sensitive, exact match).
#' var.md5checksum <- 'md5checksum_example' # character | If specified, return the references for which the `md5checksum` matches this string (case-sensitive, exact match).
#' var.is.derived <- 'is.derived_example' # character | If the reference is derived from a source sequence
#' var.min.length <- 56 # integer | The minimum length of the reference sequences to be retrieved.
#' var.max.length <- 56 # integer | The maximum length of the reference sequences to be retrieved.
#' var.page <- 0 # integer | Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is 'page'= 0). Default is `0`.
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a filtered list of `Reference` objects.
#' api.instance <- ReferencesApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ReferencesGet(reference.db.id=var.reference.db.id, reference.set.db.id=var.reference.set.db.id, accession=var.accession, md5checksum=var.md5checksum, is.derived=var.is.derived, min.length=var.min.length, max.length=var.max.length, page=var.page, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' ####################  ReferencesReferenceDbIdBasesGet  ####################
#'
#' library(openapi)
#' var.reference.db.id <- 'reference.db.id_example' # character | The ID of the `Reference` to be retrieved.
#' var.start <- 56 # integer | The start position (0-based) of this query. Defaults to 0. Genomic positions are non-negative integers less than reference length. Requests spanning the join of circular genomes are represented as two requests one on each side of the join (position 0).
#' var.end <- 56 # integer | The end position (0-based, exclusive) of this query. Defaults to the length of this `Reference`.
#' var.page.token <- 'page.token_example' # character | The continuation token, which is used to page through large result sets. To get the next page of results, set this parameter to the value of `next_page_token` from the previous response.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Lists `Reference` bases by ID and optional range.
#' api.instance <- ReferencesApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ReferencesReferenceDbIdBasesGet(var.reference.db.id, start=var.start, end=var.end, page.token=var.page.token, authorization=var.authorization)
#'
#'
#' ####################  ReferencesReferenceDbIdGet  ####################
#'
#' library(openapi)
#' var.reference.db.id <- 'reference.db.id_example' # character | The ID of the `Reference` to be retrieved.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a `Reference` by ID.
#' api.instance <- ReferencesApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ReferencesReferenceDbIdGet(var.reference.db.id, authorization=var.authorization)
#'
#'
#' ####################  SearchReferencesPost  ####################
#'
#' library(openapi)
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#' var.references.search.request <- ReferencesSearchRequest$new() # ReferencesSearchRequest | References Search request
#'
#' #Gets a list of `Reference` matching the search criteria.
#' api.instance <- ReferencesApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$SearchReferencesPost(authorization=var.authorization, references.search.request=var.references.search.request)
#'
#'
#' ####################  SearchReferencesSearchResultsDbIdGet  ####################
#'
#' library(openapi)
#' var.search.results.db.id <- 'search.results.db.id_example' # character | Unique identifier which references the search results
#' var.page <- 0 # integer | Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is 'page'= 0). Default is `0`.
#' var.page.size <- 1000 # integer | The size of the pages to be returned. Default is `1000`.
#' var.authorization <- 'Bearer XXXX' # character | HTTP HEADER - Token used for Authorization   <strong> Bearer {token_string} </strong>
#'
#' #Gets a list of `Reference` matching the search criteria.
#' api.instance <- ReferencesApi$new()
#'
#' #Configure HTTP basic authorization: AuthorizationToken
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$SearchReferencesSearchResultsDbIdGet(var.search.results.db.id, page=var.page, page.size=var.page.size, authorization=var.authorization)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ReferencesApi <- R6::R6Class(
  'ReferencesApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ReferencesGet = function(reference.db.id=NULL, reference.set.db.id=NULL, accession=NULL, md5checksum=NULL, is.derived=NULL, min.length=NULL, max.length=NULL, page=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$ReferencesGetWithHttpInfo(reference.db.id, reference.set.db.id, accession, md5checksum, is.derived, min.length, max.length, page, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ReferencesGetWithHttpInfo = function(reference.db.id=NULL, reference.set.db.id=NULL, accession=NULL, md5checksum=NULL, is.derived=NULL, min.length=NULL, max.length=NULL, page=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      headerParams['Authorization'] <- `authorization`

      queryParams['referenceDbId'] <- reference.db.id

      queryParams['referenceSetDbId'] <- reference.set.db.id

      queryParams['accession'] <- accession

      queryParams['md5checksum'] <- md5checksum

      queryParams['isDerived'] <- is.derived

      queryParams['minLength'] <- min.length

      queryParams['maxLength'] <- max.length

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/references"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ReferencesListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ReferencesReferenceDbIdBasesGet = function(reference.db.id, start=NULL, end=NULL, page.token=NULL, authorization=NULL, ...){
      apiResponse <- self$ReferencesReferenceDbIdBasesGetWithHttpInfo(reference.db.id, start, end, page.token, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ReferencesReferenceDbIdBasesGetWithHttpInfo = function(reference.db.id, start=NULL, end=NULL, page.token=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reference.db.id`)) {
        stop("Missing required parameter `reference.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      queryParams['start'] <- start

      queryParams['end'] <- end

      queryParams['pageToken'] <- page.token

      body <- NULL
      urlPath <- "/references/{referenceDbId}/bases"
      if (!missing(`reference.db.id`)) {
        urlPath <- gsub(paste0("\\{", "referenceDbId", "\\}"), URLencode(as.character(`reference.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ReferenceBasesResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ReferencesReferenceDbIdGet = function(reference.db.id, authorization=NULL, ...){
      apiResponse <- self$ReferencesReferenceDbIdGetWithHttpInfo(reference.db.id, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ReferencesReferenceDbIdGetWithHttpInfo = function(reference.db.id, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reference.db.id`)) {
        stop("Missing required parameter `reference.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      body <- NULL
      urlPath <- "/references/{referenceDbId}"
      if (!missing(`reference.db.id`)) {
        urlPath <- gsub(paste0("\\{", "referenceDbId", "\\}"), URLencode(as.character(`reference.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ReferenceSingleResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SearchReferencesPost = function(authorization=NULL, references.search.request=NULL, ...){
      apiResponse <- self$SearchReferencesPostWithHttpInfo(authorization, references.search.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SearchReferencesPostWithHttpInfo = function(authorization=NULL, references.search.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      headerParams['Authorization'] <- `authorization`

      if (!missing(`references.search.request`)) {
        body <- `references.search.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/search/references"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ReferencesListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SearchReferencesSearchResultsDbIdGet = function(search.results.db.id, page=NULL, page.size=NULL, authorization=NULL, ...){
      apiResponse <- self$SearchReferencesSearchResultsDbIdGetWithHttpInfo(search.results.db.id, page, page.size, authorization, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SearchReferencesSearchResultsDbIdGetWithHttpInfo = function(search.results.db.id, page=NULL, page.size=NULL, authorization=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`search.results.db.id`)) {
        stop("Missing required parameter `search.results.db.id`.")
      }

      headerParams['Authorization'] <- `authorization`

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      body <- NULL
      urlPath <- "/search/references/{searchResultsDbId}"
      if (!missing(`search.results.db.id`)) {
        urlPath <- gsub(paste0("\\{", "searchResultsDbId", "\\}"), URLencode(as.character(`search.results.db.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ReferencesListResponse", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
